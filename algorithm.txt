// Swaps row r1 and row r2 in the matrix
fun swap_rows(Matrix: arr(arr(num)), n: num, r1: num, r2: num)
!   require: Matrix is a n*(n+1) array ^ 0 <= r1 < len(Matrix) ^ 0 <= r2 < len(Matrix)

    for every i in [0:n+1) do
        temp := Matrix[r1][i]
        Matrix[r1][i] := Matrix[r2][i]
        Matrix[r2][i] := temp

!   ensure: the r1-th and r2-th rows are switched

fun find_pivot(Matrix: arr(arr(num)), start_row: num, col: num, n: num) -> pivot: num
!   require: Matrix is a n*(n+1) array ^ 0 <= start_row <= n ^ 0 <= col <= n ^ len(Matrix) = n

    // Finds the first row >= start_row that has a non-zero value in the specified column
    pivot := start_row
    while pivot < n and Matrix[pivot][col] == 0 do
    !   invariant: Matrix[k][col] == 0 for all k, start_row <= k < pivot
        pivot := pivot + 1
    
    return pivot

!   ensure: start_row <= pivot <= n ^ (pivot < n => Matrix[pivot][col] != 0) ^ (forall k in [start_row, pivot). Matrix[k][col] == 0)

fun normalize_pivot_row(Matrix: arr(arr(num)), row: num, col: num, n: num)
!   require: Matrix is a n*(n+1) array ^ 0 <= row < n ^ 0 <= col <= n ^ Matrix[row][col] != 0

    // Normalize the pivot row so the pivot becomes 1
    divisor := Matrix[row][col]
    j := col
    while j <= n do
    !   invariant: col <= j <= n + 1 ^ for all k in [col, j), Matrix[row][k] is divided by divisor
        Matrix[row][j] := Matrix[row][j] / divisor
        j := j + 1

!   ensure: Matrix[row][col] = 1 ^ (for all k in [col+1, n]. Matrix[row][k] is divided by the original value of Matrix[row][col])

fun eliminate_rows(Matrix: arr(arr(num)), pivot_row: num, col: num, n: num)
!   require: Matrix is a n*(n+1) array ^ 0 <= pivot_row < n ^ 0 <= col <= n ^ Matrix[pivot_row][col] = 1 
    ^ Matrix[pivot_row][j] = 0 for all 0<=j<col

    // Eliminate entries in other rows in the current column
    k := 0
    while k < n do
    !   invariant: 0 <= k <= n ^ Matrix[r][col] = 0 for all 0<=r<k and r!=pivot_row
        if k != pivot_row and Matrix[k][col] != 0 then
            factor := Matrix[k][col]
            j := col
            while j <= n do
            !   invariant: col <= j <= n + 1 ^ Matrix ^ Matrix[k][c] is proceded for all 0<=c<j
                Matrix[k][j] := Matrix[k][j] - factor * Matrix[pivot_row][j]
                j := j + 1
        k := k + 1

!   ensure: Matrix[k][col] = 0 for all k in [0, n), k != pivot_row

fun solve(n: num, Matrix: arr(arr(num))) -> result: arr(num)
!   require: Matrix[k][col] = 0 ^ n > 0 ^ len(Matrix) = n ^ len(Matrix[i]) = (n + 1) for all 0<=i<n

    // Initial state
    row := 0
    col := 0
    num_pivot := 0
    
    // Gauss-Jordan Elimination
    while row < n and col < n do
    !   invariant: Matrix is in reduced row echelon form for the processed rows and columns
                  ^ 0 <= row <= n ^ 0 <= col <= n
        
        pivot := find_pivot(Matrix, row, col, n)
            
        if pivot == n then
            // No pivot in this column, move to next column
            col := col + 1 
        else
            num_pivot := num_pivot + 1
            // Swap rows to bring the pivot to the current row
            if pivot != row then
                swap_rows(Matrix, row, pivot)
            
            normalize_pivot_row(Matrix, row, col, n)
            eliminate_rows(Matrix, row, col, n)
            
            row := row + 1
            col := col + 1

    // Determine the result type and construct the returning array
    result := []
    if num_pivot < n then
        result[0] = 0
    else
        result[0] = 1
        // construct the result
        for every i in [0, n) do
            result[i+1] := Matrix[i][n]

!   ensure: (result[0]=1 ^ result[1:n] is a solution for the system) iff the system has a unique solution
    
