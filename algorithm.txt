fun gauss_jordan(A:array(num))-> R:array(num)
! require:
       size(A) = [n][n+1]^n>0

//initial state
i :=0 //current row being proceessed
col :=0
rank :=0
//main elimination loop
while 0<i<=n ^ 0<col<=n^ 0<rank<=i do
! invariant :0<i<=n ^0<col<=n ^0<rank<=i^each row should be row-reduced echelon form
        //find a pivot in the current column
        pivot_row :=i
        while pivot_row<n ^ A[pivot_row][col]==0 do
        ! invariant:0<pivot_row<=n ^0<col<=n 
                pivot_row=pivot_row+1
        if pivot_row =n then
                col :=col + 1
        // swap row to bring the pivot to current row
        if pivot!= i then
                swap_row(A,i,pivot_row)

        j :=col
        //pivot normalization:
        pivot_value :=A[i][col]
         while j<=n do
        ! invariant :col<=j<=n
        A[i][j] :=A[i][j]/pivot_value
        j :=j+1

        row :=0
        h :=col
        // eliminate the column in all other rows to 0
        while row<n do
        !invariant :0<=row<=n-1
                if row!=i ^A[row][col]!=0 then
                        element :=A[row][col]
                        while h<=n do
                        ! invariant :col<=h<=n
                        A[row][h]:=A[row][h]- element*A[i][h]
                        h :=h+1
i :=i+1
col :=col+1
rank :=rank+1

//solution classification
inconsistent :=false
row :=rank
while row < n do
! invariant :rank<=row<n
        if A[row][n]!=0 then
                inconsistent :=true
if inconsitent then
                result :='no unqiue solutionâ€˜
elif rank=n then
        solution :=new array[n] of real numbers
        k :=0
        while k<n do
        ! invariant : 0<=k<n
                solution[k]= A[k][n]
                k :=k+1
        result :=solution
else   //has infinitely solutions
        result :='no unique solution'

! ensure:
the system has a unique solution, print: value1 . . . valuen.
v
the system does not have a unique solution, print: no unique solution.

